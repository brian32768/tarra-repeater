#!/usr/bin/python
#;           --=======================--
#;          ***  CHANGES WILL BE LOST ***
#;           --=======================--
#;
#; Edit the version in vastra-ansible and re-provision.
#
#  Generate and then apply whitelists in the iptables firewall.
#  This should be run whenever the whitelist txt files change.
#  Needs root permissions to change the firewall.
#
#  Reads text files and outputs iptables rules to files.
#
#  2017 New feature, now looks up names in input files.
#
from __future__ import print_function
import sys,os,re
import subprocess
from datetime import datetime
import socket

# INPUT files

srcdir = "/var/lib/vastra/firewall"  # for deploy, this will watched via inotify 

# Each list has one entry per line and
# can be a name (bazzle.com), ip address (1.1.1.1), or a network (123.123.123.0/24)
admin_source = os.path.join(srcdir, "admin.txt")       # these get unrestricted access
sms_source   = os.path.join(srcdir, "sms.txt")

sip_source   = os.path.join(srcdir, "sip.txt")         # these get SIP/RTP access
web_source   = os.path.join(srcdir, "web_sip.txt")
iax_source   = os.path.join(srcdir, "iax.txt")         # this gets IAX access     
twilio_sip   = os.path.join(srcdir, "twilio_sip.txt")  # twilio has its own lists
twilio_media = os.path.join(srcdir, "twilio_media.txt")

# OUTPUT files

fwdir = "/etc/network"  # for deploy
filemode = 0x755

msg = """# This file was generated by update_whitelists.py
# DON'T MAKE CHANGES HERE.
#
# If you edit the files in %s 
# this file will update automatically.

""" % srcdir

########################################################################

# This pattern strips out comments
re_comment  = re.compile(r'^(.*)\s*#.*')

# This pattern guesses if this is an ip address (dotted decimal form like 192.168.2.13)
re_ipaddr   = re.compile(r'^\d+\.\d+\.\d+\.\d+(/\d+)*$') 

def iplookup(source):
    """ Given a name returns a list of addresses. """
    return [ str(i[4][0]) for i in socket.getaddrinfo(source, 80) ]

def build_list(chain, in_fname, rules):
    """Parse a list in in_fname and return as a list of rules."""
    #print(in_fname)
    
    target = "ACCEPT" # we only build whitelists here

    # We build a dictionary to remove duplicates
    d_ipaddr = {}

    if os.path.exists(in_fname):
        with open(in_fname) as fp:
            for source in fp.readlines():

                source = source.lstrip(' \t')  # strip leading whitespace

                # strip off comments
                mo = re_comment.search(source)
                if mo: source = mo.group(1)

                source = source.rstrip(' \t\r\n') # strip trailing whitespace and newline
                if not len(source): continue # skip blank lines

                # does this look like a name or an ip address?
                #print("Testing ",source)
                mo = re_ipaddr.search(source)
                if not mo:
                    #print("matched on ",source)
                    addrs = iplookup(source)
                    #print("mo betta", source)
                    for ip in addrs:
                        d_ipaddr[ip] = 1;
                else:
                    d_ipaddr[source] = 1;

    for source in d_ipaddr:
        rules.append("iptables -A %s -j %s -s %s\n" % (chain, target, source))

    return

def write_list(rules, subchain):
    subchain_file = os.path.join(fwdir,subchain)
    
    # Remove existing table.
    if os.path.exists(subchain_file) : os.unlink(subchain_file)

    if not rules: return # nothing to do here, move along

    #print "writing", rules, "to",subchain_file
    with open(subchain_file, "w") as fp:
        fp.write("# %s %s\n" % (subchain, textstamp))
        fp.writelines(msg)
        fp.write( "# Flush previous rules from chain.\n")
        fp.write( "iptables -F %s\n" % subchain)
        fp.writelines(rules)

        # Return to the INPUT chain to allow further filtering
        fp.write("iptables -A %s -j RETURN\n" % subchain)

    os.chmod(subchain_file, filemode)
    return

# ---------------------------------

dt = datetime.now()
filestamp = dt.strftime("%Y-%m-%d_%H%M%S")
textstamp = dt.strftime("%Y-%m-%d %H:%M:%S")

# Create the lists in separate subchains so they can easily be turned on or off.

# Accept ALL traffic from ADMINISTRATOR ip addresses, this allows ssh, web, etc. -- everything.
# NOTE NOTE in deployment the INPUT chain default policy should be DROP.

print("Building and loading subchains.")

subchains = []

subchain = "admin_whitelist"
admin_rules = []
build_list(subchain, admin_source, admin_rules)
build_list(subchain, sms_source,   admin_rules)
#for rule in admin_rules: print rule,
write_list(admin_rules, subchain)
subchains.append(subchain)

# SIP and MEDIA subchains only examine traffic on ports 5060,5061,10000-20000
# IAX subchains only examine traffic on ports 4569
# As above - INPUT default should be set to DROP
# if so and it's not in this list,  then an outside PBX or phone won't work.

# twilio is a special case so its sip rules always go ahead of fail2ban
subchain = "twilio_whitelist"
sip_rules = []
build_list(subchain, twilio_sip, sip_rules)
write_list(sip_rules, subchain)
subchains.append(subchain)

subchain = "sip_whitelist"
sip_rules = []
build_list(subchain, sip_source, sip_rules)
build_list(subchain, web_source, sip_rules)
#for rule in sip_rules: print rule,
write_list(sip_rules, subchain)
subchains.append(subchain)

subchain = "iax_whitelist"
iax_rules = []
build_list(subchain, iax_source, iax_rules)
#for rule in iax_rules: print rule,
write_list(iax_rules, subchain)
subchains.append(subchain)

subchain = "media_whitelist"
media_rules = []
build_list(subchain, twilio_media, media_rules)
build_list(subchain, sip_source,   media_rules)
build_list(subchain, web_source,   media_rules)
#for rule in media_rules: print rule,
write_list(media_rules,subchain)
subchains.append(subchain)

for subchain in subchains:
    cmd = os.path.join(fwdir,subchain)
    print("cmd-->",cmd)
    try:
        subprocess.call(cmd,shell=True)
    except Exception as e:
        print(e)

# Tear down pattern
# iptables -F admin_whitelist
# iptables -D INPUT admin_whitelist
# iptables -X admin_whitelist

# deleting a chain
#  remove link
#    sudo iptables -D INPUT 1
#  remove all rules
#    sudo iptables -F voip_whitelist
#  now you can delete it
#    sudo iptables -X voip_whitelist

# That's all!

